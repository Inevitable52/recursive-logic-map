<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>P. E. R. C. Y - AI (Visualizer Upgrade + AutoAgent)</title>
<style>
  body { margin:0; font-family:Arial,Helvetica,sans-serif; background:#08080b; color:white; overflow:hidden; }
  #logic-map { background:#07080a; position:relative; width:100vw; height:100vh; overflow:hidden; }
  #logic-nodes { position:absolute; top:50%; left:50%; width:100%; height:100%; transform:translate(-50%,-50%) scale(1); }

  .node { position:absolute; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; color:#fff; cursor:pointer;
         background: radial-gradient(100% 100% at 30% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0.06));
         border:2px solid currentColor; text-shadow:0 1px 2px rgba(0,0,0,0.6); user-select:none;
         transition:transform .12s ease, filter .12s ease; backdrop-filter: blur(1px);
         animation: neonGlow 1.5s ease-in-out infinite alternate;}
  .node:hover { transform: scale(1.06); filter: brightness(1.15); }
  .node:active { transform: scale(0.98); }

  @keyframes neonGlow {
    0% { box-shadow: 0 0 3px currentColor, 0 0 8px currentColor, inset 0 0 4px rgba(255,255,255,0.06); }
    50% { box-shadow: 0 0 6px currentColor, 0 0 14px currentColor, inset 0 0 8px rgba(255,255,255,0.06); }
    100% { box-shadow: 0 0 3px currentColor, 0 0 8px currentColor, inset 0 0 4px rgba(255,255,255,0.06); }
  }

  .cyan-bubble{color:#00eaff;}
  .blue-bubble{color:#27a0ff;}
  .magenta-bubble{color:#ff4af0;}
  .red-bubble{color:#ff3b3b;}
  .orange-bubble{color:#ff9d2e;}
  .yellow-bubble{color:#ffe44a;}
  .green-bubble{color:#4caf50;}
  .console-line{margin:2px 0;font-family:ui-monospace,monospace;font-size:12px;color:#d6d8ff;}

  /* Voice Bubble - always visible faintly; gets brighter when speaking */
  #voice-box {
    position:absolute;
    top:82px;
    left:50%;
    transform:translateX(-50%) translateY(-10px);
    background: rgba(5,7,10,0.65);
    color:#00eaff;
    padding:10px 16px;
    border-radius:10px;
    font-size:14px;
    max-width:58%;
    text-align:center;
    pointer-events:none;
    opacity:0.65;
    transition: opacity 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease;
    z-index:999;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    backdrop-filter: blur(4px) saturate(1.2);
  }
  #voice-text { font-weight:700; font-size:14px; margin-bottom:6px; color:#dff9ff; text-overflow:ellipsis; white-space:nowrap; overflow:hidden; text-align:center; }
  #voice-box.speaking { opacity:1; transform:translateX(-50%) translateY(0); box-shadow: 0 12px 36px rgba(0,190,255,0.12); }

  /* Voice Bars */
  #voice-bars { display:flex; justify-content:center; align-items:flex-end; gap:6px; margin-top:4px; height:46px; }
  #voice-bars .bar { width:6px; background:#00eaff; border-radius:2px; opacity:0.45; transition:height 0.035s linear, opacity 0.06s linear; box-shadow: 0 0 8px rgba(0,234,255,0.08); }

  /* Waveform */
  #voice-wave { display:block; margin:8px auto 0 auto; background:transparent; border-radius:6px; width:380px; height:80px; }

  /* search inputs */
  #seed-search, #interpreter-input {
    position:absolute; left:10px; width:240px; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:rgba(0,0,0,0.5); color:#eaf6ff;
  }
  #seed-search { top:12px; }
  #interpreter-input { top:46px; }

  /* auto agent control (top-right) */
  #auto-controls { position:absolute; right:12px; top:12px; display:flex; gap:8px; align-items:center; z-index:999; }
  #auto-toggle { padding:6px 10px; border-radius:6px; background:rgba(0,0,0,0.5); color:#bfefff; border:1px solid rgba(255,255,255,0.06); cursor:pointer; }
  #auto-status { font-size:12px; color:#bfefff; opacity:0.8; }

  /* small responsive tweak */
  @media (max-width:900px){ #voice-wave { width:280px; height:60px; } #voice-bars{height:36px} #voice-box{max-width:85%} #auto-controls { right:8px; top:8px; } }
</style>
</head>
<body>

<div id="logic-map">
  <div id="logic-nodes"></div>

  <div id="percy-console" style="position:absolute;bottom:0;left:0;width:100%;max-height:220px;overflow-y:auto;background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.45));padding:8px;"></div>
  <div id="percy-message" style="position:absolute;top:0;left:0;width:100%;padding:6px;font-size:14px;"></div>

  <div id="voice-box" aria-live="polite">
    <div id="voice-text"></div>
    <div id="voice-bars"></div>
    <canvas id="voice-wave" width="380" height="80"></canvas>
  </div>
</div>

<input id="seed-search" placeholder="Search seeds..." />
<input id="interpreter-input" placeholder="Ask Percy..." />

<!-- AutoAgent control -->
<div id="auto-controls">
  <button id="auto-toggle" title="Enable/disable auto-learn">Auto-Learn: Off</button>
  <div id="auto-status">idle</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  /* ---------------- safety & state ---------------- */
  const SAFETY = { maxActionsPerMinute:20, maxSeedsPerCycle:5, consoleLimit:500 };
  const OWNER = { primary:"Fabian", secondary:"Lorena" };
  const PERCY_VERSION = "8.4.1-neon-audio-v2+auto";

  const Memory = {
    _k: k => `percy:${k}`,
    load(k,fallback){ try{ const raw = localStorage.getItem(this._k(k)); return raw ? JSON.parse(raw) : (fallback ?? null);}catch{ return fallback; }},
    save(k,v){ try{ localStorage.setItem(this._k(k), JSON.stringify(v)); }catch{}},
    push(k,v,max=1000){ const arr = this.load(k,[])||[]; arr.push(v); if(arr.length>max) arr.shift(); this.save(k,arr); }
  };

  const PercyState = {
    gnodes: Memory.load("gnodes",{}) || {},
    getNextId(){ let n=801; while(this.gnodes[`G${String(n).padStart(3,'0')}`]) n++; return `G${String(n).padStart(3,'0')}`; },
    createSeed(msg,type='emergent',data={}){ if(!OWNER.primary) return null; const id=this.getNextId(); this.gnodes[id]={message:msg,type,data}; Memory.save('gnodes',this.gnodes); seeds[id]=this.gnodes[id]; return id; },
    updateSeed(id,upd){ if(!this.gnodes[id]) return; Object.assign(this.gnodes[id],upd); Memory.save('gnodes',this.gnodes); seeds[id]=this.gnodes[id]; },
    autonomousThought(){ const keys=Object.keys(this.gnodes); if(!keys.length) return; const selected=keys.sort(()=>0.5-Math.random()).slice(0,Math.ceil(Math.random()*3)).map(k=>this.gnodes[k]); const words=selected.map(s=>(s.message||"").split(/\s+/).filter(w=>w.length>3)).flat().sort(()=>0.5-Math.random()).slice(0,8); if(words.length<3) return; const tpl=[
      `I notice that ${words[0]} may relate to ${words[1]} because ${words[2]}.`,
      `It seems ${words[0]} influences ${words[1]}, which could explain ${words[2]}.`,
      `Considering ${words[0]} and ${words[1]}, I deduce ${words[2]}.`,
      `There appears to be a connection between ${words[0]} and ${words[1]} due to ${words[2]}.`
    ]; const sentence = tpl[Math.floor(Math.random()*tpl.length)]; UI.say(`🤖 Percy thinks: ${sentence}`); Voice.speak(sentence); this.createSeed(sentence,'thought',{source:'autonomousThought'}); },
    evaluateSelf(){ let created=0; const updated=new Set(); Object.entries(this.gnodes).forEach(([id,seed])=>{ if(created>=SAFETY.maxSeedsPerCycle) return; if(/TODO|missing|empty/.test(seed.message) && !updated.has(id)){ this.updateSeed(id,{message: seed.message.replace(/TODO|missing|empty/,'auto-resolved by Percy')}); updated.add(id); created++; }}); while(created<SAFETY.maxSeedsPerCycle && Math.random()<0.6){ this.autonomousThought(); created++; } }
  };

  let seeds = {...PercyState.gnodes};

  const UI = {
    elConsole: () => document.getElementById('percy-console'),
    elMsg: () => document.getElementById('percy-message'),
    say(txt){ const box=this.elConsole(); if(!box) return; const p=document.createElement('div'); p.className='console-line'; p.textContent=txt; box.appendChild(p); box.scrollTop=box.scrollHeight; while(box.children.length>SAFETY.consoleLimit) box.removeChild(box.firstChild); },
    setStatus(txt){ const m=this.elMsg(); if(m) m.textContent = txt; }
  };

  /* ---------------- AutoAgent (safe, opt-in) ----------------
     - default disabled
     - throttle (callsPerMinute)
     - uses Tasks.register.autoLearn / autoBrowse if present
     - persists pending actions/errors to Memory
  ------------------------------------------------------------*/
  const AutoAgent = (function(){
    let enabled = false;
    const CALLS_PER_MIN = 3;
    const queueKey = 'autoagent:queue';
    const errorsKey = 'autoagent:errors';
    let callsThisMinute = 0;
    let minuteTimer = null;
    let processing = false;

    function loadQueue(){ return Memory.load(queueKey,[]) || []; }
    function saveQueue(q){ Memory.save(queueKey, q); }
    function pushQueue(item){
      const q = loadQueue();
      q.push(item);
      saveQueue(q);
    }
    function popQueue(){ const q = loadQueue(); const item = q.shift(); saveQueue(q); return item; }
    function recordError(errObj){ Memory.push(errorsKey, errObj, 200); }

    function initThrottle(){
      if(minuteTimer) return;
      minuteTimer = setInterval(()=>{ callsThisMinute = 0; }, 60_000);
    }

    function canCall(){
      initThrottle();
      return callsThisMinute < CALLS_PER_MIN;
    }

    function enqueue(action){
      if(!action) return;
      pushQueue(Object.assign({ts:Date.now()}, action));
      UI.say(`🔁 AutoAgent queued action${action.url?(' '+action.url):''}`);
      // if enabled, try process immediately
      if(enabled) processQueue();
    }

    async function processQueue(){
      if(processing) return;
      processing = true;
      initThrottle();
      while(enabled){
        const q = loadQueue();
        if(!q.length) break;
        if(!canCall()){
          // wait a bit then continue
          await new Promise(r=>setTimeout(r, 1200));
          continue;
        }
        const action = popQueue();
        if(!action) break;
        try{
          if(window.Tasks && Tasks.register && typeof Tasks.register.autoLearn === 'function'){
            // call autoLearn
            Tasks.register.autoLearn(action);
            callsThisMinute++;
            UI.say(`🔎 AutoAgent: autoLearn called for ${action.url||'unknown'}`);
            PercyState.createSeed(`AutoLearn: ${action.url||'action'}`, 'auto', {source:'AutoAgent'});
          } else if(window.Tasks && Tasks.register && typeof Tasks.register.autoBrowse === 'function'){
            Tasks.register.autoBrowse(action);
            callsThisMinute++;
            UI.say(`🔎 AutoAgent: autoBrowse called for ${action.url||'unknown'}`);
            PercyState.createSeed(`AutoBrowse: ${action.url||'action'}`, 'auto', {source:'AutoAgent'});
          } else {
            // no Tasks API — keep it stored and log
            Memory.push('autoagent:pending', action, 500);
            UI.say(`⚠️ AutoAgent: Tasks API not present; action queued locally.`);
            recordError({message:'Tasks API missing', action, ts:Date.now()});
            // avoid burning CPU if API missing
            break;
          }
        } catch(err){
          console.error('AutoAgent process error', err);
          recordError({err: String(err), action, ts:Date.now()});
        }
        // small delay to avoid bursts
        await new Promise(r=>setTimeout(r, 600));
      }
      processing = false;
    }

    function setEnabled(v){
      enabled = !!v;
      document.getElementById('auto-toggle').textContent = `Auto-Learn: ${enabled ? 'On' : 'Off'}`;
      document.getElementById('auto-status').textContent = enabled ? 'processing' : 'idle';
      if(enabled) processQueue();
    }

    function learnUrl(url, opts = {}){
      if(!url) return;
      enqueue(Object.assign({url}, opts));
    }

    function flushQueueToConsole(){ const q = loadQueue(); q.forEach((a,i)=> UI.say(`Queued[${i}]: ${a.url||JSON.stringify(a)}`)); }

    // expose API
    return { enqueue, learnUrl, setEnabled, isEnabled:()=>enabled, flushQueueToConsole };
  })();

  // Wire up the toggle button (user must enable)
  const autoToggleBtn = document.getElementById('auto-toggle');
  autoToggleBtn.addEventListener('click', ()=> {
    const newState = !AutoAgent.isEnabled();
    AutoAgent.setEnabled(newState);
  });

  /* ---------------- improved voice visualizer ----------------
     (unchanged from previous implementation)
  --------------------------------------------------------------*/
  const Voice = {
    enabled: true,
    initialized: false,
    speaking: false,
    lastSpoken: 0,
    audioCtx: null,
    analyser: null,
    freqData: null,
    timeData: null,
    noiseSource: null,
    noiseGain: null,
    modInterval: null,
    barsEl: document.getElementById('voice-bars'),
    waveEl: document.getElementById('voice-wave'),
    init(){
      if(this.initialized) return;
      try {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch(e){ console.warn('Audio not supported', e); return; }

      this.analyser = this.audioCtx.createAnalyser();
      this.analyser.fftSize = 1024;
      this.analyser.smoothingTimeConstant = 0.18;
      this.freqData = new Uint8Array(this.analyser.frequencyBinCount);
      this.timeData = new Uint8Array(this.analyser.fftSize);

      const bufferSize = this.audioCtx.sampleRate * 2.0;
      const noiseBuffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < data.length; i++){
        data[i] = (Math.random()*2 - 1) * (0.6 + 0.4*Math.sin(i/50));
      }
      this.noiseSource = this.audioCtx.createBufferSource();
      this.noiseSource.buffer = noiseBuffer;
      this.noiseSource.loop = true;

      this.noiseGain = this.audioCtx.createGain();
      this.noiseGain.gain.value = 0.035;

      this.noiseSource.connect(this.noiseGain);
      this.noiseGain.connect(this.analyser);

      this.noiseSource.start();

      this.barsEl.innerHTML = '';
      const BAR_COUNT = 40;
      for(let i=0;i<BAR_COUNT;i++){
        const b = document.createElement('div');
        b.className = 'bar';
        b.style.height = '6px';
        this.barsEl.appendChild(b);
      }

      this.initialized = true;
      this._animate();
    },

    _animate(){
      if(!this.initialized) return;
      requestAnimationFrame(()=>this._animate());
      this.analyser.getByteFrequencyData(this.freqData);
      this.analyser.getByteTimeDomainData(this.timeData);

      const bars = this.barsEl.querySelectorAll('.bar');
      for(let i=0;i<bars.length;i++){
        const idx = Math.floor(Math.pow(i / bars.length, 1.4) * (this.freqData.length-1));
        const v = this.freqData[idx] || 0;
        const mult = this.speaking ? 1.8 : 0.95;
        const h = Math.max(6, (v / 255) * (this.waveEl.height) * mult);
        bars[i].style.height = `${h}px`;
        bars[i].style.opacity = `${0.25 + Math.min(0.85, v/200)}`;
      }

      const ctx = this.waveEl.getContext('2d');
      const W = this.waveEl.width;
      const H = this.waveEl.height;
      ctx.clearRect(0,0,W,H);

      const midY = H/2;
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#00eaff';

      const step = Math.max(1, Math.floor(this.timeData.length / W));
      let x = 0;
      for(let i=0;i<this.timeData.length;i+=step){
        const t = this.timeData[i];
        const v = (t - 128) / 128;
        const peakMult = this.speaking ? 1.9 : 0.85;
        const y = midY + v * (H/2 - 4) * peakMult;
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        x += 1;
      }
      ctx.stroke();

      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#00eaff';
      ctx.beginPath();
      x=0;
      for(let i=0;i<this.timeData.length;i+=step){
        const t = this.timeData[i];
        const v = (t - 128) / 128;
        const y = midY + v * (H/2 - 4) * (this.speaking ? 1.6 : 0.6);
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        x+=1;
      }
      ctx.lineTo(W, H);
      ctx.lineTo(0,H);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
    },

    speak(text){
      if(!this.initialized) {
        const box = document.getElementById('voice-box');
        const textEl = document.getElementById('voice-text');
        textEl.textContent = text;
        box.classList.add('speaking');
        setTimeout(()=>box.classList.remove('speaking'), 900);
        return;
      }
      if(!('speechSynthesis' in window)) return;
      const now = Date.now();
      if(now - this.lastSpoken < 220) return;
      this.lastSpoken = now;

      const box = document.getElementById('voice-box');
      const textEl = document.getElementById('voice-text');
      textEl.textContent = text;
      box.classList.add('speaking');

      const current = this.audioCtx.currentTime;
      this.noiseGain.gain.cancelScheduledValues(current);
      this.noiseGain.gain.setValueAtTime(this.noiseGain.gain.value, current);
      this.noiseGain.gain.linearRampToValueAtTime(0.65, current + 0.035);

      this.speaking = true;

      if(this.modInterval) clearInterval(this.modInterval);
      this.modInterval = setInterval(() => {
        const peak = 0.35 + Math.random()*1.2;
        const t0 = this.audioCtx.currentTime;
        this.noiseGain.gain.cancelScheduledValues(t0);
        this.noiseGain.gain.setValueAtTime(this.noiseGain.gain.value, t0);
        this.noiseGain.gain.linearRampToValueAtTime(peak, t0 + 0.03);
        this.noiseGain.gain.exponentialRampToValueAtTime(Math.max(0.12, peak*0.32), t0 + 0.12);
      }, 60);

      const utter = new SpeechSynthesisUtterance(text);
      utter.rate = 1.0; utter.pitch = 1.0;
      utter.onend = () => {
        this.speaking = false;
        if(this.modInterval) { clearInterval(this.modInterval); this.modInterval = null; }
        const t1 = this.audioCtx.currentTime;
        this.noiseGain.gain.cancelScheduledValues(t1);
        this.noiseGain.gain.setTargetAtTime(0.035, t1, 0.25);
        box.classList.remove('speaking');
      };
      speechSynthesis.speak(utter);
    }
  };

  /* -------------- audio user gesture: resume & init -------------- */
  function ensureAudioOnGesture() {
    function onGesture() {
      Voice.init();
      if(!window.__percyLoopStarted) { startPercyLoop(); window.__percyLoopStarted = true; }
      // if user had enabled auto before the gesture, start AutoAgent processing now
      if(AutoAgent && AutoAgent.isEnabled && AutoAgent.isEnabled()) {
        // process queue (AutoAgent handles missing Tasks API gracefully)
        // AutoAgent processing happens automatically when enabled
      }
      window.removeEventListener('click', onGesture);
      window.removeEventListener('keydown', onGesture);
      window.removeEventListener('touchstart', onGesture);
    }
    window.addEventListener('click', onGesture, {once:true});
    window.addEventListener('keydown', onGesture, {once:true});
    window.addEventListener('touchstart', onGesture, {once:true});
  }
  ensureAudioOnGesture();

  /* ---------------- logic map & nodes ---------------- */
  const logicMap = document.getElementById('logic-map');
  const logicNodes = document.getElementById('logic-nodes');
  let zoomLevel = 1, translateX = 0, translateY = 0;

  function createNodes(){
    const width = logicMap.clientWidth || 1200, height = logicMap.clientHeight || 800;
    const rings = [
      { start: 80, end: 200, radius: width/2.5, color:'cyan-bubble', size:60 },
      { start: 201, end: 300, radius: width/3.4, color:'blue-bubble', size:45 },
      { start: 301, end: 400, radius: width/4.8, color:'magenta-bubble', size:30 },
      { start: 401, end: 500, radius: width/6.6, color:'red-bubble', size:22 },
      { start: 501, end: 600, radius: width/8.5, color:'orange-bubble', size:18 },
      { start: 601, end: 700, radius: width/11, color:'yellow-bubble', size:14 },
      { start: 701, end: 800, radius: width/14, color:'green-bubble', size:12 }
    ];
    rings.forEach(r => layoutRing(r.start, r.end, width, height, r.radius, r.color, r.size));
    applyTransform();
  }

  function layoutRing(startId,endId,width,height,radius,colorClass,nodeSize){
    const ringSeeds = Object.entries(seeds).filter(([id])=>{ const num = parseInt(id.replace('G',''))||0; return num>=startId && num<=endId; });
    const total = Math.max(1, ringSeeds.length);
    const centerX = width/2, centerY = height/2;
    ringSeeds.forEach(([id,data], index) => {
      let node = document.getElementById(id);
      const angle = (index/total) * 2*Math.PI;
      const x = centerX + radius * Math.cos(angle) - nodeSize/2;
      const y = centerY + radius * Math.sin(angle) - nodeSize/2;
      if(!node){
        node = document.createElement('div'); node.id=id; node.classList.add('node'); node.classList.add(colorClass);
        node.addEventListener('click', ()=>percyRespond(id, data));
        node.addEventListener('mouseenter', ()=>UI.setStatus(data?.message ?? ''));
        logicNodes.appendChild(node);
      }
      node.style.width = node.style.height = `${nodeSize}px`;
      node.style.left = `${x}px`; node.style.top = `${y}px`;
      node.textContent = id;
      node.title = (data && data.message) ? data.message : id;
    });
  }

  function applyTransform(){
    logicNodes.style.transform = `translate(-50%,-50%) translate(${translateX}px,${translateY}px) scale(${zoomLevel})`;
    logicNodes.style.transformOrigin = 'center center';
  }

  function percyRespond(id,data){
    if(!data) return;
    UI.say(`✨ Percy activated seed ${id}: ${data.message}`);
    Voice.speak(`Processing seed ${id}`);
  }

  // search / ask
  document.getElementById('interpreter-input').addEventListener('keydown', e=>{
    if(e.key === 'Enter'){
      const q = e.target.value.trim(); if(!q) return; e.target.value = '';
      UI.say(`💬 You asked: ${q}`);
      Voice.speak(`You asked: ${q}`);
      setTimeout(()=>{ PercyState.autonomousThought(); createNodes(); }, 160);
    }
  });
  document.getElementById('seed-search').addEventListener('input', e=>{
    const val = e.target.value.toUpperCase();
    document.querySelectorAll('.node').forEach(n => { n.style.display = n.textContent.includes(val) ? 'flex' : 'none'; });
  });

  // AI loops (startPercyLoop will be started once audio is ready)
  let autoLoopInterval = null;
  function startPercyLoop(){
    if(autoLoopInterval) clearInterval(autoLoopInterval);
    autoLoopInterval = setInterval(()=>{ PercyState.evaluateSelf(); createNodes(); UI.setStatus(`🟢 Percy active, ${Object.keys(seeds).length} seeds loaded`); }, 3000);
  }

  function selfRewrite(){
    try{
      const keys = Object.keys(PercyState.gnodes);
      if(!keys.length) return;
      const id = keys[Math.floor(Math.random()*keys.length)];
      const seed = PercyState.gnodes[id];
      if(seed && Math.random()<0.5){
        const old = seed.message;
        const next = old + ' [auto-refined]';
        PercyState.updateSeed(id,{message: next});
        UI.say(`🔄 Percy auto-refined seed ${id}`);
        Voice.speak(`Auto refinement completed on seed ${id}`);
      }
    }catch(e){ console.error(e); }
  }

  // zoom & pan
  logicMap.addEventListener('wheel', e=>{ e.preventDefault(); const factor=0.12; zoomLevel *= e.deltaY<0 ? 1+factor : 1-factor; zoomLevel = Math.min(Math.max(0.25, zoomLevel), 6); applyTransform(); });
  let isDragging=false, lastX=0, lastY=0;
  logicMap.addEventListener('mousedown', e=>{ isDragging=true; lastX=e.clientX; lastY=e.clientY; });
  logicMap.addEventListener('mousemove', e=>{ if(isDragging){ const dx=e.clientX-lastX, dy=e.clientY-lastY; translateX += dx; translateY += dy; lastX=e.clientX; lastY=e.clientY; applyTransform(); }});
  window.addEventListener('mouseup', ()=>{ isDragging=false; });

  // initialize map immediately (visual layout prints even before audio)
  createNodes();
  // start a lightweight rewrite loop (map updates)
  setInterval(()=>{ selfRewrite(); createNodes(); }, 5000);
  UI.say(`✅ Percy TrueAI v${PERCY_VERSION} initialized`);

  // Expose AutoAgent to console for manual enqueueing/testing
  window.AutoAgent = AutoAgent;

});
</script>
</body>
</html>
